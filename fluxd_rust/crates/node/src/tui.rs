use std::collections::{HashSet, VecDeque};
use std::fmt::Write as FmtWrite;
use std::fs;
use std::io::{self, Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

use crossterm::cursor::{Hide, Show};
use crossterm::event::{self, Event, KeyCode, KeyEvent, KeyEventKind, KeyModifiers};
use crossterm::execute;
use crossterm::terminal::{
    disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen,
};
use rand::distributions::Alphanumeric;
use rand::Rng;
use ratatui::backend::CrosstermBackend;
use ratatui::layout::{Constraint, Direction, Layout};
use ratatui::style::{Color, Modifier, Style};
use ratatui::text::{Line, Span};
use ratatui::widgets::{
    Axis, Block, Borders, Cell, Chart, Dataset, GraphType, Paragraph, Row, Table,
};
use ratatui::Terminal;
use serde_json;
use tokio::sync::watch;

use fluxd_log as logging;

use fluxd_chainstate::metrics::ConnectMetrics;
use fluxd_chainstate::state::ChainState;
use fluxd_chainstate::validation::ValidationMetrics;
use fluxd_consensus::constants::COINBASE_MATURITY;
use fluxd_consensus::params::Network;
use fluxd_consensus::Hash256;
use fluxd_primitives::OutPoint;

use crate::mempool::Mempool;
use crate::p2p::{NetTotals, PeerKind, PeerRegistry};
use crate::stats::{self, HeaderMetrics, MempoolMetrics, StatsSnapshot, SyncMetrics};
use crate::wallet::Wallet;
use crate::RunProfile;
use crate::{Backend, Store};

const HISTORY_SAMPLES: usize = 300;
const SAMPLE_INTERVAL: Duration = Duration::from_secs(1);
const UI_TICK: Duration = Duration::from_millis(200);
const LOG_SNAPSHOT_LIMIT: usize = 4096;
const WALLET_REFRESH_INTERVAL: Duration = Duration::from_secs(5);
const WALLET_RECENT_TXS: usize = 12;
const WALLET_PENDING_OPS: usize = 12;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Screen {
    Monitor,
    Peers,
    Db,
    Mempool,
    Wallet,
    Logs,
    Setup,
    Help,
}

#[derive(Clone, Debug)]
struct WalletTxRow {
    txid: Hash256,
    received_at: u64,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum SaplingNoteOwnership {
    Spendable,
    WatchOnly,
}

#[derive(Clone, Debug)]
struct SaplingNoteSummary {
    ownership: SaplingNoteOwnership,
    value: i64,
    height: i32,
    nullifier: Hash256,
}

#[derive(Clone, Debug, Default)]
struct WalletBalanceBucket {
    confirmed: i64,
    unconfirmed: i64,
    immature: i64,
}

#[derive(Clone, Debug)]
struct SetupWizard {
    data_dir: PathBuf,
    conf_path: PathBuf,
    network: Network,
    profile: RunProfile,
    rpc_user: String,
    rpc_pass: String,
    show_pass: bool,
    status: Option<String>,
}

impl SetupWizard {
    fn new(data_dir: PathBuf, network: Network) -> Self {
        let conf_path = data_dir.join("flux.conf");
        let mut wizard = Self {
            data_dir,
            conf_path,
            network,
            profile: RunProfile::Default,
            rpc_user: String::new(),
            rpc_pass: String::new(),
            show_pass: false,
            status: None,
        };
        wizard.regenerate_auth();
        wizard
    }

    fn cycle_network(&mut self) {
        self.network = match self.network {
            Network::Mainnet => Network::Testnet,
            Network::Testnet => Network::Regtest,
            Network::Regtest => Network::Mainnet,
        };
    }

    fn cycle_profile(&mut self) {
        self.profile = match self.profile {
            RunProfile::Low => RunProfile::Default,
            RunProfile::Default => RunProfile::High,
            RunProfile::High => RunProfile::Low,
        };
    }

    fn regenerate_auth(&mut self) {
        let mut rng = rand::thread_rng();
        let user_suffix: String = (&mut rng)
            .sample_iter(&Alphanumeric)
            .take(6)
            .map(char::from)
            .collect();
        let pass: String = (&mut rng)
            .sample_iter(&Alphanumeric)
            .take(32)
            .map(char::from)
            .collect();
        self.rpc_user = format!("rpc{user_suffix}");
        self.rpc_pass = pass;
        self.status = None;
    }

    fn toggle_pass_visible(&mut self) {
        self.show_pass = !self.show_pass;
    }

    fn masked_pass(&self) -> String {
        if self.show_pass {
            return self.rpc_pass.clone();
        }
        if self.rpc_pass.is_empty() {
            return "-".to_string();
        }
        let shown = self.rpc_pass.chars().take(4).collect::<String>();
        format!("{shown}â€¦")
    }

    fn write_config(&mut self) -> Result<(), String> {
        fs::create_dir_all(&self.data_dir)
            .map_err(|err| format!("failed to create data dir: {err}"))?;

        let mut contents = String::new();
        writeln!(&mut contents, "# fluxd-rust configuration file").ok();
        writeln!(
            &mut contents,
            "# Generated by the in-process TUI setup wizard."
        )
        .ok();
        writeln!(&mut contents, "").ok();
        writeln!(&mut contents, "profile={}", self.profile.as_str()).ok();
        match self.network {
            Network::Mainnet => {}
            Network::Testnet => {
                writeln!(&mut contents, "testnet=1").ok();
            }
            Network::Regtest => {
                writeln!(&mut contents, "regtest=1").ok();
            }
        }
        writeln!(&mut contents, "").ok();
        writeln!(&mut contents, "rpcuser={}", self.rpc_user).ok();
        writeln!(&mut contents, "rpcpassword={}", self.rpc_pass).ok();
        writeln!(&mut contents, "rpcbind=127.0.0.1").ok();
        writeln!(
            &mut contents,
            "rpcport={}",
            crate::default_rpc_addr(self.network).port()
        )
        .ok();
        writeln!(&mut contents, "rpcallowip=127.0.0.1").ok();

        let mut backup: Option<PathBuf> = None;
        if self.conf_path.exists() {
            let suffix = unix_seconds();
            let backup_name = format!("flux.conf.bak.{suffix}");
            let backup_path = self.data_dir.join(backup_name);
            if let Err(_err) = fs::rename(&self.conf_path, &backup_path) {
                fs::copy(&self.conf_path, &backup_path)
                    .map_err(|err| format!("failed to backup existing flux.conf: {err}"))?;
                fs::remove_file(&self.conf_path)
                    .map_err(|err| format!("failed to remove old flux.conf: {err}"))?;
            }
            backup = Some(backup_path);
        }

        fs::write(&self.conf_path, contents)
            .map_err(|err| format!("failed to write flux.conf: {err}"))?;
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let _ = fs::set_permissions(&self.conf_path, fs::Permissions::from_mode(0o600));
        }

        self.status = Some(match backup {
            Some(path) => format!(
                "Wrote {} (backed up previous to {}). Restart the daemon to apply.",
                self.conf_path.display(),
                path.display()
            ),
            None => format!(
                "Wrote {}. Restart the daemon to apply.",
                self.conf_path.display()
            ),
        });
        Ok(())
    }
}

struct RatePoint {
    t: f64,
    value: f64,
}

struct RateHistory {
    points: VecDeque<RatePoint>,
    capacity: usize,
}

impl RateHistory {
    fn new(capacity: usize) -> Self {
        Self {
            points: VecDeque::with_capacity(capacity),
            capacity,
        }
    }

    fn push(&mut self, point: RatePoint) {
        if self.points.len() == self.capacity {
            let _ = self.points.pop_front();
        }
        self.points.push_back(point);
    }

    fn bounds(&self) -> (f64, f64) {
        let Some(last) = self.points.back() else {
            return (0.0, 1.0);
        };
        let min_t = self.points.front().map(|point| point.t).unwrap_or(last.t);
        (min_t, last.t.max(min_t + 1.0))
    }

    fn max_y(&self) -> f64 {
        self.points
            .iter()
            .map(|point| point.value)
            .fold(0.0, f64::max)
            .max(1.0)
    }

    fn as_vec(&self) -> Vec<(f64, f64)> {
        self.points
            .iter()
            .map(|point| (point.t, point.value))
            .collect()
    }
}

struct TuiState {
    screen: Screen,
    help_return: Screen,
    setup_return: Screen,
    advanced: bool,
    last_snapshot: Option<StatsSnapshot>,
    last_rate_snapshot: Option<StatsSnapshot>,
    last_error: Option<String>,
    blocks_per_sec: Option<f64>,
    headers_per_sec: Option<f64>,
    orphan_count: Option<usize>,
    orphan_bytes: Option<usize>,
    logs_min_level: logging::Level,
    logs_follow: bool,
    logs_paused: bool,
    logs_scroll: u16,
    logs: Vec<logging::CapturedLog>,
    wallet_encrypted: Option<bool>,
    wallet_unlocked_until: Option<u64>,
    wallet_key_count: Option<usize>,
    wallet_keypool_size: Option<usize>,
    wallet_tx_count: Option<usize>,
    wallet_pay_tx_fee_per_kb: Option<i64>,
    wallet_has_sapling_keys: Option<bool>,
    wallet_transparent: Option<WalletBalanceBucket>,
    wallet_transparent_watchonly: Option<WalletBalanceBucket>,
    wallet_sapling_spendable: Option<i64>,
    wallet_sapling_watchonly: Option<i64>,
    wallet_sapling_scan_height: Option<i32>,
    wallet_sapling_note_count: Option<usize>,
    wallet_recent_txs: Vec<WalletTxRow>,
    wallet_pending_ops: Vec<crate::rpc::AsyncOpSnapshot>,
    wallet_detail_error: Option<String>,
    setup: Option<SetupWizard>,
    bps_history: RateHistory,
    hps_history: RateHistory,
}

impl TuiState {
    fn new() -> Self {
        Self {
            screen: Screen::Monitor,
            help_return: Screen::Monitor,
            setup_return: Screen::Monitor,
            advanced: false,
            last_snapshot: None,
            last_rate_snapshot: None,
            last_error: None,
            blocks_per_sec: None,
            headers_per_sec: None,
            orphan_count: None,
            orphan_bytes: None,
            logs_min_level: logging::Level::Info,
            logs_follow: true,
            logs_paused: false,
            logs_scroll: 0,
            logs: Vec::new(),
            wallet_encrypted: None,
            wallet_unlocked_until: None,
            wallet_key_count: None,
            wallet_keypool_size: None,
            wallet_tx_count: None,
            wallet_pay_tx_fee_per_kb: None,
            wallet_has_sapling_keys: None,
            wallet_transparent: None,
            wallet_transparent_watchonly: None,
            wallet_sapling_spendable: None,
            wallet_sapling_watchonly: None,
            wallet_sapling_scan_height: None,
            wallet_sapling_note_count: None,
            wallet_recent_txs: Vec::new(),
            wallet_pending_ops: Vec::new(),
            wallet_detail_error: None,
            setup: None,
            bps_history: RateHistory::new(HISTORY_SAMPLES),
            hps_history: RateHistory::new(HISTORY_SAMPLES),
        }
    }

    fn toggle_help(&mut self) {
        match self.screen {
            Screen::Help => {
                self.screen = self.help_return;
            }
            other => {
                self.help_return = other;
                self.screen = Screen::Help;
            }
        }
    }

    fn toggle_setup(&mut self) {
        match self.screen {
            Screen::Setup => {
                self.screen = self.setup_return;
            }
            other => {
                self.setup_return = other;
                self.screen = Screen::Setup;
            }
        }
    }

    fn cycle_screen(&mut self) {
        self.screen = match self.screen {
            Screen::Monitor => Screen::Peers,
            Screen::Peers => Screen::Db,
            Screen::Db => Screen::Mempool,
            Screen::Mempool => Screen::Wallet,
            Screen::Wallet => Screen::Logs,
            Screen::Logs => Screen::Monitor,
            Screen::Setup => self.setup_return,
            Screen::Help => self.help_return,
        };
    }

    fn toggle_advanced(&mut self) {
        self.advanced = !self.advanced;
    }

    fn update_snapshot(&mut self, snapshot: StatsSnapshot) {
        let (headers_per_sec, blocks_per_sec) = match self.last_rate_snapshot.as_ref() {
            Some(prev) => {
                let dt = snapshot.unix_time_secs.saturating_sub(prev.unix_time_secs);
                if dt == 0 {
                    (None, None)
                } else {
                    let headers_delta = snapshot.header_count.saturating_sub(prev.header_count);
                    let blocks_delta = snapshot.block_count.saturating_sub(prev.block_count);
                    (
                        Some(headers_delta as f64 / dt as f64),
                        Some(blocks_delta as f64 / dt as f64),
                    )
                }
            }
            None => (None, None),
        };

        self.headers_per_sec = headers_per_sec;
        self.blocks_per_sec = blocks_per_sec;

        let t = snapshot.uptime_secs as f64;
        if let Some(value) = blocks_per_sec {
            self.bps_history.push(RatePoint { t, value });
        }
        if let Some(value) = headers_per_sec {
            self.hps_history.push(RatePoint { t, value });
        }

        self.last_rate_snapshot = Some(snapshot.clone());
        self.last_snapshot = Some(snapshot);
        self.last_error = None;
    }

    fn update_error(&mut self, err: String) {
        self.last_error = Some(err);
    }

    fn update_orphans(&mut self, orphan_count: Option<usize>, orphan_bytes: Option<usize>) {
        self.orphan_count = orphan_count;
        self.orphan_bytes = orphan_bytes;
    }

    fn update_wallet(
        &mut self,
        wallet_encrypted: Option<bool>,
        wallet_unlocked_until: Option<u64>,
        wallet_key_count: Option<usize>,
        wallet_keypool_size: Option<usize>,
        wallet_tx_count: Option<usize>,
        wallet_pay_tx_fee_per_kb: Option<i64>,
        wallet_has_sapling_keys: Option<bool>,
    ) {
        self.wallet_encrypted = wallet_encrypted;
        self.wallet_unlocked_until = wallet_unlocked_until;
        self.wallet_key_count = wallet_key_count;
        self.wallet_keypool_size = wallet_keypool_size;
        self.wallet_tx_count = wallet_tx_count;
        self.wallet_pay_tx_fee_per_kb = wallet_pay_tx_fee_per_kb;
        self.wallet_has_sapling_keys = wallet_has_sapling_keys;
    }

    fn update_logs(&mut self, logs: Vec<logging::CapturedLog>) {
        self.logs = logs;
    }

    fn cycle_logs_min_level(&mut self) {
        self.logs_min_level = match self.logs_min_level {
            logging::Level::Error => logging::Level::Warn,
            logging::Level::Warn => logging::Level::Info,
            logging::Level::Info => logging::Level::Debug,
            logging::Level::Debug => logging::Level::Trace,
            logging::Level::Trace => logging::Level::Error,
        };
    }

    fn toggle_logs_pause(&mut self) {
        self.logs_paused = !self.logs_paused;
        if self.logs_paused {
            self.logs_follow = false;
        } else {
            self.logs_follow = true;
            self.logs_scroll = 0;
        }
    }
}

struct TerminalGuard;

impl TerminalGuard {
    fn enter() -> Result<Self, String> {
        enable_raw_mode().map_err(|err| err.to_string())?;
        let mut stdout = io::stdout();
        execute!(stdout, EnterAlternateScreen, Hide).map_err(|err| err.to_string())?;
        Ok(Self)
    }
}

impl Drop for TerminalGuard {
    fn drop(&mut self) {
        let _ = disable_raw_mode();
        let mut stdout = io::stdout();
        let _ = execute!(stdout, Show, LeaveAlternateScreen);
    }
}

pub fn run_tui(
    chainstate: Arc<ChainState<Store>>,
    store: Arc<Store>,
    data_dir: PathBuf,
    sync_metrics: Arc<SyncMetrics>,
    header_metrics: Arc<HeaderMetrics>,
    validation_metrics: Arc<ValidationMetrics>,
    connect_metrics: Arc<ConnectMetrics>,
    mempool: Arc<Mutex<Mempool>>,
    mempool_metrics: Arc<MempoolMetrics>,
    wallet: Arc<Mutex<Wallet>>,
    net_totals: Arc<NetTotals>,
    peer_registry: Arc<PeerRegistry>,
    network: Network,
    storage_backend: Backend,
    start_time: Instant,
    shutdown_rx: watch::Receiver<bool>,
    shutdown_tx: watch::Sender<bool>,
) -> Result<(), String> {
    let _guard = TerminalGuard::enter()?;
    let stdout = io::stdout();
    let term_backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(term_backend).map_err(|err| err.to_string())?;
    terminal.clear().map_err(|err| err.to_string())?;

    let mut state = TuiState::new();
    state.setup = Some(SetupWizard::new(data_dir, network));
    let mut next_sample = Instant::now();
    let mut next_wallet_refresh = Instant::now();

    loop {
        if *shutdown_rx.borrow() {
            break;
        }

        let now = Instant::now();
        if now >= next_sample {
            match stats::snapshot_stats(
                chainstate.as_ref(),
                Some(store.as_ref()),
                network,
                storage_backend,
                start_time,
                Some(sync_metrics.as_ref()),
                Some(header_metrics.as_ref()),
                Some(validation_metrics.as_ref()),
                Some(connect_metrics.as_ref()),
                Some(mempool.as_ref()),
                Some(mempool_metrics.as_ref()),
            ) {
                Ok(snapshot) => {
                    state.update_snapshot(snapshot);
                    let (orphan_count, orphan_bytes) = match mempool.lock() {
                        Ok(guard) => (Some(guard.orphan_count()), Some(guard.orphan_bytes())),
                        Err(_) => (None, None),
                    };
                    state.update_orphans(orphan_count, orphan_bytes);

                    let wallet_snapshot = match wallet.lock() {
                        Ok(mut guard) => (
                            Some(guard.is_encrypted()),
                            Some(guard.unlocked_until()),
                            Some(guard.key_count()),
                            Some(guard.keypool_size()),
                            Some(guard.tx_count()),
                            Some(guard.pay_tx_fee_per_kb()),
                            Some(guard.has_sapling_keys()),
                        ),
                        Err(_) => (None, None, None, None, None, None, None),
                    };
                    state.update_wallet(
                        wallet_snapshot.0,
                        wallet_snapshot.1,
                        wallet_snapshot.2,
                        wallet_snapshot.3,
                        wallet_snapshot.4,
                        wallet_snapshot.5,
                        wallet_snapshot.6,
                    );
                }
                Err(err) => {
                    state.update_error(err);
                    state.update_orphans(None, None);
                    state.update_wallet(None, None, None, None, None, None, None);
                }
            }

            if matches!(state.screen, Screen::Logs) && !state.logs_paused {
                state.update_logs(logging::capture_snapshot(LOG_SNAPSHOT_LIMIT));
            }
            if matches!(state.screen, Screen::Wallet) && now >= next_wallet_refresh {
                let tip_height = state
                    .last_snapshot
                    .as_ref()
                    .map(|snap| snap.best_block_height);
                match refresh_wallet_details(
                    chainstate.as_ref(),
                    mempool.as_ref(),
                    wallet.as_ref(),
                    tip_height,
                ) {
                    Ok(details) => {
                        state.wallet_transparent = Some(details.transparent_owned);
                        state.wallet_transparent_watchonly = Some(details.transparent_watchonly);
                        state.wallet_sapling_spendable = Some(details.sapling_spendable);
                        state.wallet_sapling_watchonly = Some(details.sapling_watchonly);
                        state.wallet_sapling_scan_height = Some(details.sapling_scan_height);
                        state.wallet_sapling_note_count = Some(details.sapling_note_count);
                        state.wallet_recent_txs = details.recent_txs;
                        state.wallet_pending_ops = details.pending_ops;
                        state.wallet_detail_error = None;
                    }
                    Err(err) => {
                        state.wallet_transparent = None;
                        state.wallet_transparent_watchonly = None;
                        state.wallet_sapling_spendable = None;
                        state.wallet_sapling_watchonly = None;
                        state.wallet_sapling_scan_height = None;
                        state.wallet_sapling_note_count = None;
                        state.wallet_recent_txs.clear();
                        state.wallet_pending_ops.clear();
                        state.wallet_detail_error = Some(err);
                    }
                }
                next_wallet_refresh = now + WALLET_REFRESH_INTERVAL;
            }
            next_sample = now + SAMPLE_INTERVAL;
        }

        terminal
            .draw(|frame| draw(frame, &state, peer_registry.as_ref(), net_totals.as_ref()))
            .map_err(|err| err.to_string())?;

        if event::poll(UI_TICK).map_err(|err| err.to_string())? {
            if let Event::Key(key) = event::read().map_err(|err| err.to_string())? {
                if key.kind == KeyEventKind::Press {
                    if handle_key(key, &mut state, &shutdown_tx)? {
                        break;
                    }
                }
            }
        }
    }

    terminal.show_cursor().map_err(|err| err.to_string())?;
    Ok(())
}

pub fn run_remote_tui(endpoint: String) -> Result<(), String> {
    let endpoint = endpoint.trim().to_string();
    if endpoint.is_empty() {
        return Err("missing --tui-attach endpoint".to_string());
    }

    let _guard = TerminalGuard::enter()?;
    let stdout = io::stdout();
    let term_backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(term_backend).map_err(|err| err.to_string())?;
    terminal.clear().map_err(|err| err.to_string())?;

    let (shutdown_tx, shutdown_rx) = watch::channel(false);
    let peer_registry = PeerRegistry::default();
    let net_totals = NetTotals::default();

    let mut state = TuiState::new();
    state.logs_min_level = logging::Level::Warn;
    let mut next_sample = Instant::now();

    loop {
        if *shutdown_rx.borrow() {
            break;
        }

        let now = Instant::now();
        if now >= next_sample {
            match fetch_remote_stats_snapshot(&endpoint) {
                Ok(snapshot) => {
                    state.update_snapshot(snapshot);
                }
                Err(err) => {
                    state.update_error(err);
                }
            }
            next_sample = now + SAMPLE_INTERVAL;
        }

        terminal
            .draw(|frame| draw(frame, &state, &peer_registry, &net_totals))
            .map_err(|err| err.to_string())?;

        if event::poll(UI_TICK).map_err(|err| err.to_string())? {
            if let Event::Key(key) = event::read().map_err(|err| err.to_string())? {
                if key.kind == KeyEventKind::Press {
                    if handle_key(key, &mut state, &shutdown_tx)? {
                        break;
                    }
                }
            }
        }
    }

    terminal.show_cursor().map_err(|err| err.to_string())?;
    Ok(())
}

fn fetch_remote_stats_snapshot(endpoint: &str) -> Result<StatsSnapshot, String> {
    let endpoint = endpoint.trim();
    let endpoint = endpoint
        .strip_prefix("http://")
        .or_else(|| endpoint.strip_prefix("https://"))
        .unwrap_or(endpoint);
    let endpoint = endpoint.trim_end_matches('/');

    let (host, port) = endpoint
        .rsplit_once(':')
        .and_then(|(host, port)| port.parse::<u16>().ok().map(|port| (host, port)))
        .unwrap_or((endpoint, 8080));
    if host.is_empty() {
        return Err("invalid --tui-attach endpoint".to_string());
    }

    let addr = format!("{host}:{port}");
    let mut stream = TcpStream::connect(&addr).map_err(|err| format!("connect {addr}: {err}"))?;
    let _ = stream.set_read_timeout(Some(Duration::from_secs(2)));
    let _ = stream.set_write_timeout(Some(Duration::from_secs(2)));

    let request = format!("GET /stats HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\n\r\n");
    stream
        .write_all(request.as_bytes())
        .map_err(|err| format!("write request: {err}"))?;
    let mut response_bytes = Vec::new();
    stream
        .read_to_end(&mut response_bytes)
        .map_err(|err| format!("read response: {err}"))?;

    let response = String::from_utf8(response_bytes)
        .map_err(|_| "remote response not valid utf-8".to_string())?;
    let (head, body) = response
        .split_once("\r\n\r\n")
        .ok_or_else(|| "invalid http response".to_string())?;
    let status_line = head.lines().next().unwrap_or_default();
    if !status_line.contains("200") {
        return Err(format!("remote returned '{status_line}'"));
    }

    serde_json::from_str::<StatsSnapshot>(body).map_err(|err| format!("invalid stats json: {err}"))
}

struct WalletDetails {
    transparent_owned: WalletBalanceBucket,
    transparent_watchonly: WalletBalanceBucket,
    sapling_spendable: i64,
    sapling_watchonly: i64,
    sapling_scan_height: i32,
    sapling_note_count: usize,
    recent_txs: Vec<WalletTxRow>,
    pending_ops: Vec<crate::rpc::AsyncOpSnapshot>,
}

fn refresh_wallet_details(
    chainstate: &ChainState<Store>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    tip_height: Option<i32>,
) -> Result<WalletDetails, String> {
    let (
        scripts,
        watch_script_set,
        sapling_scan_height,
        sapling_note_count,
        sapling_notes,
        recent_txs,
    ) = {
        let guard = wallet
            .lock()
            .map_err(|_| "wallet lock poisoned".to_string())?;
        let scripts = guard
            .all_script_pubkeys_including_watchonly()
            .map_err(|err| err.to_string())?;
        let mut watch_scripts = HashSet::new();
        for script in &scripts {
            if guard.script_pubkey_is_watchonly(script) {
                watch_scripts.insert(script.clone());
            }
        }

        let sapling_scan_height = guard.sapling_scan_height();
        let sapling_note_count = guard.sapling_note_count();
        let mut sapling_notes = Vec::new();
        if guard.has_sapling_keys() {
            for note in guard.sapling_note_map().values() {
                let is_mine = guard
                    .sapling_address_is_mine(&note.address)
                    .map_err(|err| err.to_string())?;
                let ownership = if is_mine {
                    Some(SaplingNoteOwnership::Spendable)
                } else if guard
                    .sapling_address_is_watchonly(&note.address)
                    .map_err(|err| err.to_string())?
                {
                    Some(SaplingNoteOwnership::WatchOnly)
                } else {
                    None
                };
                let Some(ownership) = ownership else {
                    continue;
                };
                sapling_notes.push(SaplingNoteSummary {
                    ownership,
                    value: note.value,
                    height: note.height,
                    nullifier: note.nullifier,
                });
            }
        }

        let recent_txs = guard
            .recent_transactions(WALLET_RECENT_TXS)
            .into_iter()
            .map(|(txid, received_at)| WalletTxRow { txid, received_at })
            .collect::<Vec<_>>();

        (
            scripts,
            watch_scripts,
            sapling_scan_height,
            sapling_note_count,
            sapling_notes,
            recent_txs,
        )
    };

    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, true)?;
    let mut owned = WalletBalanceBucket::default();
    let mut watch = WalletBalanceBucket::default();
    for utxo in utxos {
        let bucket = if watch_script_set.contains(&utxo.script_pubkey) {
            &mut watch
        } else {
            &mut owned
        };

        if utxo.confirmations == 0 {
            bucket.unconfirmed = bucket
                .unconfirmed
                .checked_add(utxo.value)
                .ok_or_else(|| "wallet balance overflow".to_string())?;
            continue;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            bucket.immature = bucket
                .immature
                .checked_add(utxo.value)
                .ok_or_else(|| "wallet balance overflow".to_string())?;
            continue;
        }
        bucket.confirmed = bucket
            .confirmed
            .checked_add(utxo.value)
            .ok_or_else(|| "wallet balance overflow".to_string())?;
    }

    let best_height = tip_height
        .or_else(|| chainstate.best_block().ok().flatten().map(|tip| tip.height))
        .unwrap_or(0);
    let mut sapling_spendable = 0i64;
    let mut sapling_watchonly = 0i64;
    let mut chain_spend_status: Vec<(SaplingNoteSummary, bool)> = Vec::new();
    chain_spend_status.reserve(sapling_notes.len());
    for note in sapling_notes {
        let confirmations = best_height.saturating_sub(note.height).saturating_add(1);
        if confirmations < 1 {
            continue;
        }
        let spent = chainstate
            .sapling_nullifier_spent(&note.nullifier)
            .map_err(|err| err.to_string())?;
        chain_spend_status.push((note, spent));
    }
    let mempool_guard = mempool
        .lock()
        .map_err(|_| "mempool lock poisoned".to_string())?;
    for (note, spent_in_chain) in chain_spend_status {
        if spent_in_chain {
            continue;
        }
        if mempool_guard
            .sapling_nullifier_spender(&note.nullifier)
            .is_some()
        {
            continue;
        }
        match note.ownership {
            SaplingNoteOwnership::Spendable => {
                sapling_spendable = sapling_spendable
                    .checked_add(note.value)
                    .ok_or_else(|| "wallet balance overflow".to_string())?;
            }
            SaplingNoteOwnership::WatchOnly => {
                sapling_watchonly = sapling_watchonly
                    .checked_add(note.value)
                    .ok_or_else(|| "wallet balance overflow".to_string())?;
            }
        }
    }

    let pending_ops = crate::rpc::tui_async_ops_snapshot(0)
        .into_iter()
        .filter(|op| matches!(op.status.as_str(), "queued" | "executing"))
        .take(WALLET_PENDING_OPS)
        .collect::<Vec<_>>();

    Ok(WalletDetails {
        transparent_owned: owned,
        transparent_watchonly: watch,
        sapling_spendable,
        sapling_watchonly,
        sapling_scan_height,
        sapling_note_count,
        recent_txs,
        pending_ops,
    })
}

#[derive(Clone)]
struct WalletUtxoRow {
    outpoint: OutPoint,
    value: i64,
    script_pubkey: Vec<u8>,
    is_coinbase: bool,
    confirmations: i32,
}

fn collect_wallet_utxos(
    chainstate: &ChainState<Store>,
    mempool: &Mutex<Mempool>,
    scripts: &[Vec<u8>],
    include_mempool_outputs: bool,
) -> Result<Vec<WalletUtxoRow>, String> {
    if scripts.is_empty() {
        return Ok(Vec::new());
    }

    let best_height = chainstate
        .best_block()
        .map_err(|err| err.to_string())?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let mut seen: HashSet<OutPoint> = HashSet::new();
    let mut out = Vec::new();
    for script_pubkey in scripts {
        let outpoints = chainstate
            .address_outpoints(script_pubkey)
            .map_err(|err| err.to_string())?;
        for outpoint in outpoints {
            if !seen.insert(outpoint.clone()) {
                continue;
            }
            let entry = chainstate
                .utxo_entry(&outpoint)
                .map_err(|err| err.to_string())?
                .ok_or_else(|| "missing utxo entry".to_string())?;
            let height_i32 = i32::try_from(entry.height).unwrap_or(0);
            let confirmations = if best_height >= height_i32 {
                best_height.saturating_sub(height_i32).saturating_add(1)
            } else {
                0
            };
            out.push(WalletUtxoRow {
                outpoint,
                value: entry.value,
                script_pubkey: entry.script_pubkey,
                is_coinbase: entry.is_coinbase,
                confirmations,
            });
        }
    }

    let mempool_guard = mempool
        .lock()
        .map_err(|_| "mempool lock poisoned".to_string())?;
    out.retain(|row| !mempool_guard.is_spent(&row.outpoint));

    if include_mempool_outputs {
        for entry in mempool_guard.entries() {
            for (output_index, output) in entry.tx.vout.iter().enumerate() {
                if !scripts
                    .iter()
                    .any(|script| script.as_slice() == output.script_pubkey.as_slice())
                {
                    continue;
                }
                let outpoint = OutPoint {
                    hash: entry.txid,
                    index: output_index as u32,
                };
                if mempool_guard.is_spent(&outpoint) {
                    continue;
                }
                if !seen.insert(outpoint.clone()) {
                    continue;
                }
                out.push(WalletUtxoRow {
                    outpoint,
                    value: output.value,
                    script_pubkey: output.script_pubkey.clone(),
                    is_coinbase: false,
                    confirmations: 0,
                });
            }
        }
    }
    Ok(out)
}

fn handle_key(
    key: KeyEvent,
    state: &mut TuiState,
    shutdown_tx: &watch::Sender<bool>,
) -> Result<bool, String> {
    if matches!(state.screen, Screen::Setup) {
        match (key.code, key.modifiers) {
            (KeyCode::Esc, _) => {
                state.toggle_setup();
                return Ok(false);
            }
            (KeyCode::Char('s'), _) => {
                state.toggle_setup();
                return Ok(false);
            }
            (KeyCode::Char('n'), _) => {
                if let Some(setup) = state.setup.as_mut() {
                    setup.cycle_network();
                }
                return Ok(false);
            }
            (KeyCode::Char('p'), _) => {
                if let Some(setup) = state.setup.as_mut() {
                    setup.cycle_profile();
                }
                return Ok(false);
            }
            (KeyCode::Char('g'), _) => {
                if let Some(setup) = state.setup.as_mut() {
                    setup.regenerate_auth();
                }
                return Ok(false);
            }
            (KeyCode::Char('v'), _) => {
                if let Some(setup) = state.setup.as_mut() {
                    setup.toggle_pass_visible();
                }
                return Ok(false);
            }
            (KeyCode::Char('w'), _) => {
                if let Some(setup) = state.setup.as_mut() {
                    if let Err(err) = setup.write_config() {
                        setup.status = Some(format!("Error: {err}"));
                    }
                }
                return Ok(false);
            }
            _ => {}
        }
    }

    match (key.code, key.modifiers) {
        (KeyCode::Char('q'), _) | (KeyCode::Esc, _) => {
            let _ = shutdown_tx.send(true);
            Ok(true)
        }
        (KeyCode::Char('c'), KeyModifiers::CONTROL) => {
            let _ = shutdown_tx.send(true);
            Ok(true)
        }
        (KeyCode::Char('?'), _) => {
            state.toggle_help();
            Ok(false)
        }
        (KeyCode::Char('s'), _) => {
            state.toggle_setup();
            Ok(false)
        }
        (KeyCode::Tab, _) => {
            state.cycle_screen();
            Ok(false)
        }
        (KeyCode::Char('a'), _) => {
            state.toggle_advanced();
            Ok(false)
        }
        (KeyCode::Char('f'), _) => {
            if matches!(state.screen, Screen::Logs) {
                state.cycle_logs_min_level();
            }
            Ok(false)
        }
        (KeyCode::Char(' '), _) => {
            if matches!(state.screen, Screen::Logs) {
                state.toggle_logs_pause();
            }
            Ok(false)
        }
        (KeyCode::Char('c'), _) => {
            if matches!(state.screen, Screen::Logs) {
                logging::clear_captured_logs();
                state.logs.clear();
                state.logs_scroll = 0;
                state.logs_follow = true;
                state.logs_paused = false;
            }
            Ok(false)
        }
        (KeyCode::Up, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_follow = false;
                state.logs_scroll = state.logs_scroll.saturating_sub(1);
            }
            Ok(false)
        }
        (KeyCode::Down, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_follow = false;
                state.logs_scroll = state.logs_scroll.saturating_add(1);
            }
            Ok(false)
        }
        (KeyCode::PageUp, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_follow = false;
                state.logs_scroll = state.logs_scroll.saturating_sub(10);
            }
            Ok(false)
        }
        (KeyCode::PageDown, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_follow = false;
                state.logs_scroll = state.logs_scroll.saturating_add(10);
            }
            Ok(false)
        }
        (KeyCode::Home, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_follow = false;
                state.logs_paused = true;
                state.logs_scroll = 0;
            }
            Ok(false)
        }
        (KeyCode::End, _) => {
            if matches!(state.screen, Screen::Logs) {
                state.logs_paused = false;
                state.logs_follow = true;
                state.logs_scroll = 0;
            }
            Ok(false)
        }
        (KeyCode::Char('m'), _) => {
            state.screen = Screen::Monitor;
            Ok(false)
        }
        (KeyCode::Char('p'), _) => {
            state.screen = Screen::Peers;
            Ok(false)
        }
        (KeyCode::Char('d'), _) => {
            state.screen = Screen::Db;
            Ok(false)
        }
        (KeyCode::Char('t'), _) => {
            state.screen = Screen::Mempool;
            Ok(false)
        }
        (KeyCode::Char('w'), _) => {
            state.screen = Screen::Wallet;
            Ok(false)
        }
        (KeyCode::Char('l'), _) => {
            state.screen = Screen::Logs;
            Ok(false)
        }
        (KeyCode::Char('1'), _) => {
            state.screen = Screen::Monitor;
            Ok(false)
        }
        (KeyCode::Char('2'), _) => {
            state.screen = Screen::Peers;
            Ok(false)
        }
        (KeyCode::Char('3'), _) => {
            state.screen = Screen::Db;
            Ok(false)
        }
        (KeyCode::Char('4'), _) => {
            state.screen = Screen::Mempool;
            Ok(false)
        }
        (KeyCode::Char('5'), _) => {
            state.screen = Screen::Wallet;
            Ok(false)
        }
        (KeyCode::Char('6'), _) => {
            state.screen = Screen::Logs;
            Ok(false)
        }
        (KeyCode::Char('h'), _) => {
            state.toggle_help();
            Ok(false)
        }
        _ => Ok(false),
    }
}

fn draw(
    frame: &mut ratatui::Frame<'_>,
    state: &TuiState,
    peer_registry: &PeerRegistry,
    net_totals: &NetTotals,
) {
    match state.screen {
        Screen::Monitor => draw_monitor(frame, state),
        Screen::Peers => draw_peers(frame, state, peer_registry, net_totals),
        Screen::Db => draw_db(frame, state),
        Screen::Mempool => draw_mempool(frame, state),
        Screen::Wallet => draw_wallet(frame, state),
        Screen::Logs => draw_logs(frame, state),
        Screen::Setup => draw_setup(frame, state),
        Screen::Help => draw_help(frame, state),
    }
}

fn draw_help(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let title = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("TUI Help", Style::default().fg(Color::Cyan)),
    ]);
    let lines = vec![
        Line::raw(""),
        Line::raw("Keys:"),
        Line::raw("  q / Esc     Quit (requests daemon shutdown)"),
        Line::raw("  Tab         Cycle views"),
        Line::raw("  1 / m       Monitor view"),
        Line::raw("  2 / p       Peers view"),
        Line::raw("  3 / d       DB view"),
        Line::raw("  4 / t       Mempool view"),
        Line::raw("  5 / w       Wallet view"),
        Line::raw("  6 / l       Logs view"),
        Line::raw("  ? / h       Toggle help"),
        Line::raw("  s           Toggle setup wizard"),
        Line::raw("  a           Toggle advanced metrics"),
        Line::raw(""),
        Line::raw("Logs view:"),
        Line::raw("  f           Cycle level filter"),
        Line::raw("  Space       Pause/follow toggle"),
        Line::raw("  c           Clear captured logs"),
        Line::raw("  Up/Down     Scroll"),
        Line::raw("  Home/End    Top/Follow"),
        Line::raw(""),
        Line::raw("Notes:"),
        Line::raw("  - Normal mode is in-process (internal stats, no HTTP)."),
        Line::raw("  - Remote attach mode polls http://HOST:PORT/stats."),
        Line::raw("  - For a clean display, run with --log-level warn (default under --tui)."),
    ];
    let paragraph = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title(title))
        .style(Style::default());
    frame.render_widget(paragraph, frame.area());

    if state.advanced {
        // no-op for now; keeps the state meaningful on the help page.
    }
}

fn draw_setup(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let title = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Setup Wizard", Style::default().fg(Color::Cyan)),
    ]);

    let mut lines: Vec<Line> = Vec::new();
    lines.push(Line::raw(""));
    match state.setup.as_ref() {
        Some(setup) => {
            let network = match setup.network {
                Network::Mainnet => "mainnet",
                Network::Testnet => "testnet",
                Network::Regtest => "regtest",
            };
            lines.push(Line::raw(
                "Writes a starter `flux.conf` with RPC auth + basic settings.",
            ));
            lines.push(Line::raw(""));
            lines.push(Line::from(vec![
                Span::styled("Data dir:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {}", setup.data_dir.display())),
            ]));
            lines.push(Line::from(vec![
                Span::styled("flux.conf:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {}", setup.conf_path.display())),
            ]));
            lines.push(Line::raw(""));
            lines.push(Line::from(vec![
                Span::styled("Network:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {network}")),
            ]));
            lines.push(Line::from(vec![
                Span::styled("Profile:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {}", setup.profile.as_str())),
            ]));
            lines.push(Line::raw(""));
            lines.push(Line::from(vec![
                Span::styled("rpcuser:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {}", setup.rpc_user)),
            ]));
            lines.push(Line::from(vec![
                Span::styled("rpcpassword:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {}", setup.masked_pass())),
            ]));
            lines.push(Line::raw(""));
            lines.push(Line::from(vec![
                Span::styled("Keys:", Style::default().fg(Color::DarkGray)),
                Span::raw(" n network  p profile  g regen auth  v show/hide pass  w write flux.conf  Esc back"),
            ]));

            if let Some(status) = setup.status.as_ref() {
                lines.push(Line::raw(""));
                lines.push(Line::from(vec![
                    Span::styled("Status:", Style::default().fg(Color::Yellow)),
                    Span::raw(" "),
                    Span::raw(status),
                ]));
            }
        }
        None => {
            lines.push(Line::raw("Setup wizard unavailable (remote attach mode)."));
        }
    }

    let paragraph = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title(title))
        .style(Style::default());
    frame.render_widget(paragraph, frame.area());
}

fn draw_monitor(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let area = frame.area();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(7), Constraint::Min(10)])
        .split(area);

    let header_line = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Monitor", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("?", Style::default().fg(Color::Yellow)),
        Span::raw(" help  "),
        Span::styled("a", Style::default().fg(Color::Yellow)),
        Span::raw(" advanced"),
    ]);

    let mut summary = Vec::new();
    summary.push(header_line);

    if let Some(snapshot) = state.last_snapshot.as_ref() {
        let hps = state
            .headers_per_sec
            .map(|value| format!("{value:.2}"))
            .unwrap_or_else(|| "-".to_string());
        let bps = state
            .blocks_per_sec
            .map(|value| format!("{value:.2}"))
            .unwrap_or_else(|| "-".to_string());

        summary.push(Line::from(vec![
            Span::styled("Network:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(" {}  ", snapshot.network)),
            Span::styled("Backend:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(" {}  ", snapshot.backend)),
            Span::styled("Uptime:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(" {}s", snapshot.uptime_secs)),
        ]));

        summary.push(Line::from(vec![
            Span::styled("Tip:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(
                " headers {}  blocks {}  gap {}  ",
                snapshot.best_header_height, snapshot.best_block_height, snapshot.header_gap
            )),
            Span::styled("Rates:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(" h/s {hps}  b/s {bps}")),
        ]));

        let mempool_mb = snapshot.mempool_bytes as f64 / (1024.0 * 1024.0);
        let mempool_cap_mb = snapshot.mempool_max_bytes as f64 / (1024.0 * 1024.0);
        summary.push(Line::from(vec![
            Span::styled("Mempool:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(
                " {} tx  {:.1}/{:.0} MiB",
                snapshot.mempool_size, mempool_mb, mempool_cap_mb
            )),
        ]));

        if state.advanced {
            let writebuf_mb = snapshot
                .db_write_buffer_bytes
                .map(|bytes| bytes as f64 / (1024.0 * 1024.0))
                .map(|value| format!("{value:.0}"))
                .unwrap_or_else(|| "-".to_string());
            let writebuf_max_mb = snapshot
                .db_max_write_buffer_bytes
                .map(|bytes| bytes as f64 / (1024.0 * 1024.0))
                .map(|value| format!("{value:.0}"))
                .unwrap_or_else(|| "-".to_string());
            let compactions = snapshot
                .db_active_compactions
                .map(|value| value.to_string())
                .unwrap_or_else(|| "-".to_string());
            summary.push(Line::from(vec![
                Span::styled("DB:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(
                    " writebuf {writebuf_mb}/{writebuf_max_mb} MiB  compactions {compactions}"
                )),
            ]));
        }
    } else {
        summary.push(Line::raw(""));
        summary.push(Line::raw("Waiting for stats..."));
    }

    if let Some(err) = state.last_error.as_ref() {
        summary.push(Line::from(vec![
            Span::styled("Error:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    let summary_widget =
        Paragraph::new(summary).block(Block::default().borders(Borders::ALL).title("Status"));
    frame.render_widget(summary_widget, chunks[0]);

    let (x_min, x_max) = state.bps_history.bounds();
    let y_max = state.bps_history.max_y().max(state.hps_history.max_y());
    let y_max = (y_max * 1.1).ceil().max(1.0);

    let bps_points = state.bps_history.as_vec();
    let hps_points = state.hps_history.as_vec();

    let datasets = vec![
        Dataset::default()
            .name("b/s")
            .graph_type(GraphType::Line)
            .data(&bps_points)
            .style(Style::default().fg(Color::Cyan)),
        Dataset::default()
            .name("h/s")
            .graph_type(GraphType::Line)
            .data(&hps_points)
            .style(Style::default().fg(Color::Yellow)),
    ];

    let chart = Chart::new(datasets)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Throughput (last ~5m)"),
        )
        .x_axis(
            Axis::default()
                .style(Style::default().fg(Color::DarkGray))
                .bounds([x_min, x_max]),
        )
        .y_axis(
            Axis::default()
                .style(Style::default().fg(Color::DarkGray))
                .bounds([0.0, y_max]),
        );

    frame.render_widget(chart, chunks[1]);
}

fn draw_peers(
    frame: &mut ratatui::Frame<'_>,
    state: &TuiState,
    peer_registry: &PeerRegistry,
    net_totals: &NetTotals,
) {
    let area = frame.area();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(6), Constraint::Min(10)])
        .split(area);

    let totals = net_totals.snapshot();
    let peers = peer_registry.snapshot();
    let mut block_peers = 0usize;
    let mut header_peers = 0usize;
    let mut relay_peers = 0usize;
    for peer in &peers {
        match peer.kind {
            PeerKind::Block => block_peers += 1,
            PeerKind::Header => header_peers += 1,
            PeerKind::Relay => relay_peers += 1,
        }
    }

    let header = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Peers", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("?", Style::default().fg(Color::Yellow)),
        Span::raw(" help  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit"),
    ]);

    let recv_mb = totals.bytes_recv as f64 / (1024.0 * 1024.0);
    let sent_mb = totals.bytes_sent as f64 / (1024.0 * 1024.0);
    let mut summary = Vec::new();
    summary.push(header);
    summary.push(Line::from(vec![
        Span::styled("Connections:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(
            " {}  (block {block_peers}  header {header_peers}  relay {relay_peers})",
            totals.connections
        )),
    ]));
    summary.push(Line::from(vec![
        Span::styled("Net totals:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" recv {:.1} MiB  sent {:.1} MiB", recv_mb, sent_mb)),
    ]));
    if let Some(snapshot) = state.last_snapshot.as_ref() {
        summary.push(Line::from(vec![
            Span::styled("Tip:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(
                " headers {}  blocks {}",
                snapshot.best_header_height, snapshot.best_block_height
            )),
        ]));
    }

    let summary_widget =
        Paragraph::new(summary).block(Block::default().borders(Borders::ALL).title("Network"));
    frame.render_widget(summary_widget, chunks[0]);

    let mut rows = peers;
    rows.sort_by(|a, b| {
        let kind_a = peer_kind_sort_key(a.kind);
        let kind_b = peer_kind_sort_key(b.kind);
        kind_a
            .cmp(&kind_b)
            .then_with(|| a.inbound.cmp(&b.inbound))
            .then_with(|| a.addr.cmp(&b.addr))
    });

    let max_rows = chunks[1].height.saturating_sub(3) as usize;
    rows.truncate(max_rows);

    let header_row = Row::new(vec![
        Cell::from("kind"),
        Cell::from("dir"),
        Cell::from("addr"),
        Cell::from("height"),
        Cell::from("ver"),
        Cell::from("ua"),
    ])
    .style(Style::default().add_modifier(Modifier::BOLD))
    .bottom_margin(1);

    let table_rows = rows.into_iter().map(|peer| {
        let dir = if peer.inbound { "in" } else { "out" };
        let ua = shorten(&peer.user_agent, 32);
        Row::new(vec![
            Cell::from(peer_kind_label(peer.kind)),
            Cell::from(dir),
            Cell::from(peer.addr.to_string()),
            Cell::from(peer.start_height.to_string()),
            Cell::from(peer.version.to_string()),
            Cell::from(ua),
        ])
    });

    let widths = [
        Constraint::Length(6),
        Constraint::Length(4),
        Constraint::Length(22),
        Constraint::Length(8),
        Constraint::Length(7),
        Constraint::Min(10),
    ];
    let table = Table::new(table_rows, widths)
        .header(header_row)
        .block(Block::default().borders(Borders::ALL).title("Peer list"))
        .column_spacing(1);
    frame.render_widget(table, chunks[1]);
}

fn draw_db(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let area = frame.area();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(7), Constraint::Min(10)])
        .split(area);

    let header = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("DB", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("?", Style::default().fg(Color::Yellow)),
        Span::raw(" help  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit"),
    ]);

    let mut summary = Vec::new();
    summary.push(header);
    match state.last_snapshot.as_ref() {
        Some(snapshot) => {
            let writebuf = fmt_opt_mib(snapshot.db_write_buffer_bytes);
            let writebuf_max = fmt_opt_mib(snapshot.db_max_write_buffer_bytes);
            let journal_bytes = fmt_opt_mib(snapshot.db_journal_disk_space_bytes);
            let journal_max = fmt_opt_mib(snapshot.db_max_journal_bytes);
            let journals = fmt_opt_u64(snapshot.db_journal_count);
            let flushes = fmt_opt_u64(snapshot.db_flushes_completed);
            let compactions_active = fmt_opt_u64(snapshot.db_active_compactions);
            let compactions_done = fmt_opt_u64(snapshot.db_compactions_completed);
            let compact_s = snapshot
                .db_time_compacting_us
                .map(|us| format!("{:.1}s", us as f64 / 1_000_000.0))
                .unwrap_or_else(|| "-".to_string());

            summary.push(Line::from(vec![
                Span::styled("Write buffer:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {writebuf}/{writebuf_max}")),
            ]));
            summary.push(Line::from(vec![
                Span::styled("Journal:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {journals}  {journal_bytes}/{journal_max}")),
            ]));
            summary.push(Line::from(vec![
                Span::styled("Flushes:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {flushes}")),
                Span::raw("  "),
                Span::styled("Compactions:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(
                    " active {compactions_active}  done {compactions_done}  time {compact_s}"
                )),
            ]));
        }
        None => summary.push(Line::raw("Waiting for stats...")),
    }

    if let Some(err) = state.last_error.as_ref() {
        summary.push(Line::from(vec![
            Span::styled("Error:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    let summary_widget =
        Paragraph::new(summary).block(Block::default().borders(Borders::ALL).title("Fjall status"));
    frame.render_widget(summary_widget, chunks[0]);

    let Some(snapshot) = state.last_snapshot.as_ref() else {
        return;
    };

    let rows = vec![
        (
            "utxo",
            fmt_opt_u64(snapshot.db_utxo_segments),
            fmt_opt_u64(snapshot.db_utxo_flushes_completed),
        ),
        (
            "txindex",
            fmt_opt_u64(snapshot.db_tx_index_segments),
            fmt_opt_u64(snapshot.db_tx_index_flushes_completed),
        ),
        (
            "spentindex",
            fmt_opt_u64(snapshot.db_spent_index_segments),
            fmt_opt_u64(snapshot.db_spent_index_flushes_completed),
        ),
        (
            "address_outpoint",
            fmt_opt_u64(snapshot.db_address_outpoint_segments),
            fmt_opt_u64(snapshot.db_address_outpoint_flushes_completed),
        ),
        (
            "address_delta",
            fmt_opt_u64(snapshot.db_address_delta_segments),
            fmt_opt_u64(snapshot.db_address_delta_flushes_completed),
        ),
        (
            "header_index",
            fmt_opt_u64(snapshot.db_header_index_segments),
            fmt_opt_u64(snapshot.db_header_index_flushes_completed),
        ),
    ];

    let header_row = Row::new(vec![
        Cell::from("partition"),
        Cell::from("segments"),
        Cell::from("flushes"),
    ])
    .style(Style::default().add_modifier(Modifier::BOLD))
    .bottom_margin(1);

    let table_rows = rows.into_iter().map(|(name, segments, flushes)| {
        Row::new(vec![
            Cell::from(name),
            Cell::from(segments),
            Cell::from(flushes),
        ])
    });

    let widths = [
        Constraint::Length(20),
        Constraint::Length(12),
        Constraint::Length(12),
    ];
    let table = Table::new(table_rows, widths)
        .header(header_row)
        .block(Block::default().borders(Borders::ALL).title("Partitions"))
        .column_spacing(1);
    frame.render_widget(table, chunks[1]);
}

fn draw_mempool(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let header = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Mempool", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("?", Style::default().fg(Color::Yellow)),
        Span::raw(" help  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit"),
    ]);

    let mut lines = Vec::new();
    lines.push(header);

    match state.last_snapshot.as_ref() {
        Some(snapshot) => {
            let mempool_mb = snapshot.mempool_bytes as f64 / (1024.0 * 1024.0);
            let mempool_cap_mb = snapshot.mempool_max_bytes as f64 / (1024.0 * 1024.0);
            let orphan_count = state
                .orphan_count
                .map(|value| value.to_string())
                .unwrap_or_else(|| "-".to_string());
            let orphan_mb = state
                .orphan_bytes
                .map(|bytes| bytes as f64 / (1024.0 * 1024.0))
                .map(|value| format!("{value:.2}"))
                .unwrap_or_else(|| "-".to_string());

            lines.push(Line::from(vec![
                Span::styled("Mempool:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(
                    " {} tx  {:.1}/{:.0} MiB",
                    snapshot.mempool_size, mempool_mb, mempool_cap_mb
                )),
                Span::raw("  "),
                Span::styled("Orphans:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(" {orphan_count} tx  {orphan_mb} MiB")),
            ]));

            lines.push(Line::from(vec![
                Span::styled("RPC:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(
                    " accept {}  reject {}",
                    snapshot.mempool_rpc_accept, snapshot.mempool_rpc_reject
                )),
                Span::raw("  "),
                Span::styled("Relay:", Style::default().fg(Color::DarkGray)),
                Span::raw(format!(
                    " accept {}  reject {}",
                    snapshot.mempool_relay_accept, snapshot.mempool_relay_reject
                )),
            ]));

            if state.advanced {
                let evicted_mb = snapshot.mempool_evicted_bytes as f64 / (1024.0 * 1024.0);
                let persisted_mb = snapshot.mempool_persisted_bytes as f64 / (1024.0 * 1024.0);
                lines.push(Line::from(vec![
                    Span::styled("Evicted:", Style::default().fg(Color::DarkGray)),
                    Span::raw(format!(
                        " {} ({:.2} MiB)",
                        snapshot.mempool_evicted, evicted_mb
                    )),
                    Span::raw("  "),
                    Span::styled("Loaded:", Style::default().fg(Color::DarkGray)),
                    Span::raw(format!(
                        " {}  (reject {})",
                        snapshot.mempool_loaded, snapshot.mempool_load_reject
                    )),
                ]));
                lines.push(Line::from(vec![
                    Span::styled("Persist:", Style::default().fg(Color::DarkGray)),
                    Span::raw(format!(
                        " writes {}  {:.2} MiB",
                        snapshot.mempool_persisted_writes, persisted_mb
                    )),
                ]));
            }
        }
        None => lines.push(Line::raw("Waiting for stats...")),
    }

    if let Some(err) = state.last_error.as_ref() {
        lines.push(Line::from(vec![
            Span::styled("Error:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    let widget = Paragraph::new(lines).block(Block::default().borders(Borders::ALL).title("Pool"));
    frame.render_widget(widget, frame.area());
}

fn draw_wallet(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let area = frame.area();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(13), Constraint::Min(10)])
        .split(area);

    let header = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Wallet", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("?", Style::default().fg(Color::Yellow)),
        Span::raw(" help  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit"),
    ]);

    let mut lines = Vec::new();
    lines.push(header);

    let now = unix_seconds();
    let encrypted = state.wallet_encrypted;
    let unlocked_until = state.wallet_unlocked_until.unwrap_or(0);
    let locked = encrypted.unwrap_or(false) && (unlocked_until == 0 || unlocked_until <= now);
    let unlocked_left = unlocked_until.saturating_sub(now);

    let encrypted_label = match encrypted {
        Some(true) => "yes",
        Some(false) => "no",
        None => "-",
    };
    let status = if encrypted == Some(false) {
        "unlocked (unencrypted)"
    } else if locked {
        "locked"
    } else if encrypted == Some(true) && unlocked_until > now {
        "unlocked"
    } else {
        "-"
    };
    let unlocked_for = if encrypted == Some(true) && unlocked_until > now {
        format!("{unlocked_left}s")
    } else {
        "-".to_string()
    };

    lines.push(Line::from(vec![
        Span::styled("Encrypted:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {encrypted_label}  ")),
        Span::styled("Status:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {status}  ")),
        Span::styled("Unlocked for:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {unlocked_for}")),
    ]));

    let key_count = state
        .wallet_key_count
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string());
    let keypool = state
        .wallet_keypool_size
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string());
    let tx_count = state
        .wallet_tx_count
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string());
    let sapling = match state.wallet_has_sapling_keys {
        Some(true) => "yes",
        Some(false) => "no",
        None => "-",
    };
    let paytxfee = state
        .wallet_pay_tx_fee_per_kb
        .map(|value| format!("{value} zats/kB"))
        .unwrap_or_else(|| "-".to_string());

    lines.push(Line::from(vec![
        Span::styled("Keys:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {key_count}  ")),
        Span::styled("Keypool:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {keypool}  ")),
        Span::styled("Sapling:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {sapling}  ")),
        Span::styled("Wallet txs:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {tx_count}")),
    ]));
    lines.push(Line::from(vec![
        Span::styled("paytxfee:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {paytxfee}")),
    ]));

    if let Some(snapshot) = state.last_snapshot.as_ref() {
        lines.push(Line::from(vec![
            Span::styled("Tip:", Style::default().fg(Color::DarkGray)),
            Span::raw(format!(
                " headers {}  blocks {}",
                snapshot.best_header_height, snapshot.best_block_height
            )),
        ]));
    }

    let transparent = state.wallet_transparent.as_ref();
    let watch = state.wallet_transparent_watchonly.as_ref();
    let sapling_spendable = fmt_opt_amount(state.wallet_sapling_spendable);
    let sapling_watchonly = fmt_opt_amount(state.wallet_sapling_watchonly);
    let sapling_notes = state
        .wallet_sapling_note_count
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string());
    let scan_height = state
        .wallet_sapling_scan_height
        .and_then(|value| (value >= 0).then_some(value))
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string());
    let behind = state
        .last_snapshot
        .as_ref()
        .and_then(|snap| {
            state
                .wallet_sapling_scan_height
                .and_then(|h| (h >= 0).then_some(snap.best_block_height - h))
        })
        .filter(|delta| *delta >= 0)
        .map(|delta| delta.to_string())
        .unwrap_or_else(|| "-".to_string());

    lines.push(Line::raw(""));
    lines.push(Line::from(vec![
        Span::styled("Transparent (owned):", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(
            " confirmed {}  unconf {}  immature {}",
            fmt_opt_amount(transparent.map(|b| b.confirmed)),
            fmt_opt_amount(transparent.map(|b| b.unconfirmed)),
            fmt_opt_amount(transparent.map(|b| b.immature)),
        )),
    ]));
    lines.push(Line::from(vec![
        Span::styled("Transparent (watch):", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(
            " confirmed {}  unconf {}  immature {}",
            fmt_opt_amount(watch.map(|b| b.confirmed)),
            fmt_opt_amount(watch.map(|b| b.unconfirmed)),
            fmt_opt_amount(watch.map(|b| b.immature)),
        )),
    ]));
    lines.push(Line::from(vec![
        Span::styled("Sapling:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(
            " spendable {sapling_spendable}  watch {sapling_watchonly}"
        )),
    ]));
    lines.push(Line::from(vec![
        Span::styled("Sapling scan:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(
            " height {scan_height}  behind {behind}  notes {sapling_notes}"
        )),
    ]));

    if let Some(err) = state.wallet_detail_error.as_ref() {
        lines.push(Line::from(vec![
            Span::styled("Wallet:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    if let Some(err) = state.last_error.as_ref() {
        lines.push(Line::from(vec![
            Span::styled("Error:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    let summary_widget =
        Paragraph::new(lines).block(Block::default().borders(Borders::ALL).title("Info"));
    frame.render_widget(summary_widget, chunks[0]);

    let lower_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(60), Constraint::Percentage(40)])
        .split(chunks[1]);

    let tx_header = Row::new(vec![Cell::from("age"), Cell::from("txid")])
        .style(Style::default().add_modifier(Modifier::BOLD))
        .bottom_margin(1);
    let tx_rows = state.wallet_recent_txs.iter().map(|entry| {
        let age = unix_seconds().saturating_sub(entry.received_at);
        Row::new(vec![
            Cell::from(format_age(age)),
            Cell::from(shorten_suffix(&stats::hash256_to_hex(&entry.txid), 40)),
        ])
    });
    let tx_table = Table::new(tx_rows, [Constraint::Length(10), Constraint::Min(10)])
        .header(tx_header)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Recent wallet transactions"),
        )
        .column_spacing(1);
    frame.render_widget(tx_table, lower_chunks[0]);

    let op_header = Row::new(vec![
        Cell::from("status"),
        Cell::from("method"),
        Cell::from("age"),
        Cell::from("opid"),
    ])
    .style(Style::default().add_modifier(Modifier::BOLD))
    .bottom_margin(1);
    let op_rows = state.wallet_pending_ops.iter().map(|entry| {
        let age_base = entry
            .finished_time
            .or(entry.started_time)
            .unwrap_or(entry.creation_time);
        let age = unix_seconds().saturating_sub(age_base);
        let status_style = match entry.status.as_str() {
            "queued" => Style::default().fg(Color::Yellow),
            "executing" => Style::default().fg(Color::Cyan),
            "failed" => Style::default().fg(Color::Red),
            "success" => Style::default().fg(Color::Green),
            _ => Style::default().fg(Color::White),
        };
        Row::new(vec![
            Cell::from(Span::styled(entry.status.clone(), status_style)),
            Cell::from(shorten(&entry.method, 12)),
            Cell::from(format_age(age)),
            Cell::from(shorten_suffix(&entry.operationid, 18)),
        ])
    });
    let op_table = Table::new(
        op_rows,
        [
            Constraint::Length(9),
            Constraint::Length(14),
            Constraint::Length(8),
            Constraint::Min(10),
        ],
    )
    .header(op_header)
    .block(Block::default().borders(Borders::ALL).title("Pending ops"))
    .column_spacing(1);
    frame.render_widget(op_table, lower_chunks[1]);
}

fn draw_logs(frame: &mut ratatui::Frame<'_>, state: &TuiState) {
    let area = frame.area();
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(6), Constraint::Min(10)])
        .split(area);

    let header = Line::from(vec![
        Span::styled("fluxd-rust", Style::default().add_modifier(Modifier::BOLD)),
        Span::raw("  "),
        Span::styled("Logs", Style::default().fg(Color::Cyan)),
        Span::raw("  "),
        Span::styled("Tab", Style::default().fg(Color::Yellow)),
        Span::raw(" views  "),
        Span::styled("1-6", Style::default().fg(Color::Yellow)),
        Span::raw(" jump  "),
        Span::styled("q", Style::default().fg(Color::Yellow)),
        Span::raw(" quit"),
    ]);

    let paused = if state.logs_paused { "yes" } else { "no" };
    let follow = if state.logs_follow { "yes" } else { "no" };
    let min_level = state.logs_min_level.as_str();
    let total = state.logs.len();

    let mut summary = Vec::new();
    summary.push(header);
    summary.push(Line::from(vec![
        Span::styled("Filter:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" <= {min_level}  ")),
        Span::styled("Paused:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {paused}  ")),
        Span::styled("Follow:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {follow}  ")),
        Span::styled("Lines:", Style::default().fg(Color::DarkGray)),
        Span::raw(format!(" {total}")),
    ]));
    summary.push(Line::from(vec![
        Span::styled("Keys:", Style::default().fg(Color::DarkGray)),
        Span::raw(" f filter  Space pause/follow  c clear  Up/Down scroll  End follow"),
    ]));

    if let Some(err) = state.last_error.as_ref() {
        summary.push(Line::from(vec![
            Span::styled("Error:", Style::default().fg(Color::Red)),
            Span::raw(" "),
            Span::raw(err),
        ]));
    }

    let summary_widget =
        Paragraph::new(summary).block(Block::default().borders(Borders::ALL).title("Log capture"));
    frame.render_widget(summary_widget, chunks[0]);

    let mut lines: Vec<Line> = Vec::new();
    for entry in state.logs.iter() {
        if (entry.level as u8) > (state.logs_min_level as u8) {
            continue;
        }
        let ts = format_log_ts(entry.ts_ms);
        let level_style = log_level_style(entry.level);
        let level = entry.level.as_str();
        let target = shorten_suffix(entry.target, 36);
        let msg = sanitize_log_message(&entry.msg);
        if state.advanced {
            let location = format!("{}:{}", shorten_suffix(entry.file, 24), entry.line);
            lines.push(Line::from(vec![
                Span::styled(ts, Style::default().fg(Color::DarkGray)),
                Span::raw(" "),
                Span::styled(level, level_style),
                Span::raw(" "),
                Span::styled(target, Style::default().fg(Color::LightBlue)),
                Span::raw(" "),
                Span::styled(location, Style::default().fg(Color::DarkGray)),
                Span::raw(" "),
                Span::raw(msg),
            ]));
        } else {
            lines.push(Line::from(vec![
                Span::styled(ts, Style::default().fg(Color::DarkGray)),
                Span::raw(" "),
                Span::styled(level, level_style),
                Span::raw(" "),
                Span::styled(target, Style::default().fg(Color::LightBlue)),
                Span::raw(" "),
                Span::raw(msg),
            ]));
        }
    }
    if lines.is_empty() {
        lines.push(Line::raw("No captured logs."));
    }

    let view_height = chunks[1].height.saturating_sub(2) as usize;
    let max_scroll = lines.len().saturating_sub(view_height);
    let scroll = if state.logs_follow {
        max_scroll
    } else {
        (state.logs_scroll as usize).min(max_scroll)
    };
    let scroll_u16 = u16::try_from(scroll).unwrap_or(u16::MAX);

    let widget = Paragraph::new(lines)
        .scroll((scroll_u16, 0))
        .block(Block::default().borders(Borders::ALL).title("Log lines"));
    frame.render_widget(widget, chunks[1]);
}

fn peer_kind_sort_key(kind: PeerKind) -> u8 {
    match kind {
        PeerKind::Block => 0,
        PeerKind::Header => 1,
        PeerKind::Relay => 2,
    }
}

fn peer_kind_label(kind: PeerKind) -> &'static str {
    match kind {
        PeerKind::Block => "block",
        PeerKind::Header => "header",
        PeerKind::Relay => "relay",
    }
}

fn shorten(value: &str, max: usize) -> String {
    let trimmed = value.trim();
    if trimmed.len() <= max {
        return trimmed.to_string();
    }
    let end = trimmed
        .char_indices()
        .nth(max)
        .map(|(idx, _)| idx)
        .unwrap_or(trimmed.len());
    format!("{}â€¦", trimmed[..end].trim_end())
}

fn shorten_suffix(value: &str, max: usize) -> String {
    let trimmed = value.trim();
    if max == 0 {
        return String::new();
    }
    let char_count = trimmed.chars().count();
    if char_count <= max {
        return trimmed.to_string();
    }
    let keep = max.saturating_sub(1);
    if keep == 0 {
        return "â€¦".to_string();
    }
    let skip = char_count.saturating_sub(keep);
    let start = trimmed
        .char_indices()
        .nth(skip)
        .map(|(idx, _)| idx)
        .unwrap_or(0);
    format!("â€¦{}", &trimmed[start..])
}

fn log_level_style(level: logging::Level) -> Style {
    match level {
        logging::Level::Error => Style::default().fg(Color::Red).add_modifier(Modifier::BOLD),
        logging::Level::Warn => Style::default()
            .fg(Color::Yellow)
            .add_modifier(Modifier::BOLD),
        logging::Level::Info => Style::default().fg(Color::White),
        logging::Level::Debug => Style::default().fg(Color::Cyan),
        logging::Level::Trace => Style::default().fg(Color::DarkGray),
    }
}

fn format_log_ts(ts_ms: u64) -> String {
    const SECS_PER_DAY: u64 = 86_400;
    let secs = ts_ms / 1000;
    let millis = ts_ms % 1000;
    let secs_of_day = secs % SECS_PER_DAY;
    let hour = secs_of_day / 3600;
    let minute = (secs_of_day % 3600) / 60;
    let second = secs_of_day % 60;
    format!("{hour:02}:{minute:02}:{second:02}.{millis:03}")
}

fn sanitize_log_message(msg: &str) -> String {
    let mut out = String::with_capacity(msg.len());
    for ch in msg.chars() {
        match ch {
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            _ => out.push(ch),
        }
    }
    out
}

fn fmt_opt_u64(value: Option<u64>) -> String {
    value
        .map(|value| value.to_string())
        .unwrap_or_else(|| "-".to_string())
}

fn fmt_opt_mib(value: Option<u64>) -> String {
    value
        .map(|bytes| bytes as f64 / (1024.0 * 1024.0))
        .map(|mib| format!("{mib:.0} MiB"))
        .unwrap_or_else(|| "-".to_string())
}

fn unix_seconds() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};

    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
}

fn fmt_opt_amount(value: Option<i64>) -> String {
    value
        .map(|value| crate::format_amount(value as i128))
        .unwrap_or_else(|| "-".to_string())
}

fn format_age(secs: u64) -> String {
    if secs < 60 {
        return format!("{secs}s");
    }
    let mins = secs / 60;
    if mins < 60 {
        return format!("{mins}m");
    }
    let hours = mins / 60;
    if hours < 24 {
        return format!("{hours}h");
    }
    let days = hours / 24;
    format!("{days}d")
}
